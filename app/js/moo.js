// Generated by CoffeeScript 1.7.1
(function() {
  var WorkflowTreeCtrl,
    __hasProp = {}.hasOwnProperty,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  angular.module("moo.directives", []).directive("mooNavMenu", [
    "$route", "Areas", function($route, Areas) {
      return {
        restrict: "E",
        templateUrl: "partials/nav-menu.html",
        scope: {},
        link: function($scope) {
          var area;
          $scope.tabs = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = Areas.length; _i < _len; _i++) {
              area = Areas[_i];
              _results.push({
                title: area.name,
                url: "#" + area.defaultRoute.url,
                selected: area.name === $route.current.provide.area
              });
            }
            return _results;
          })();
          return $scope.$on("$routeChangeSuccess", function(evt, newRoute) {
            var tab, _i, _len, _ref, _results;
            _ref = $scope.tabs;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              tab = _ref[_i];
              _results.push(tab.selected = tab.title === newRoute.provide.area);
            }
            return _results;
          });
        }
      };
    }
  ]).directive("mooSearchField", [
    function() {
      return {
        restrict: "E",
        templateUrl: "partials/search-field.html",
        scope: {
          searchText: "="
        }
      };
    }
  ]).directive("mooAjaxSpinner", [
    "$http", function($http) {
      return {
        restrict: "E",
        templateUrl: "partials/ajax-spinner.html",
        scope: {},
        link: function($scope, $element) {
          var spinner;
          $scope.isLoading = function() {
            return $http.pendingRequests.length > 0;
          };
          spinner = $element.find("#spinner");
          return $scope.$watch($scope.isLoading, function(v) {
            if (v) {
              return spinner.show();
            } else {
              return spinner.hide();
            }
          });
        }
      };
    }
  ]).directive("mooEditableVariables", [
    function() {
      return {
        restrict: "E",
        templateUrl: "partials/editable-variables.html",
        scope: {
          variables: "="
        },
        link: function($scope, element) {
          element.on("keypress", function(evt) {
            return evt.which !== 13;
          });
          $scope.addVariable = function() {
            return $scope.variables.push({
              name: "",
              value: ""
            });
          };
          return $scope.removeVariable = function(variableToRemove) {
            return $scope.variables.m$removeFirst(function(v) {
              return variableToRemove.name === v.name && variableToRemove.value === v.value;
            });
          };
        }
      };
    }
  ]).directive("mooReadOnlyVariables", [
    function() {
      return {
        restrict: "E",
        templateUrl: "partials/read-only-variables.html",
        scope: {
          variables: "="
        }
      };
    }
  ]).directive("mooWorkflowTree", [
    function() {
      return {
        restrict: "E",
        templateUrl: "partials/workflow-tree.html",
        scope: {
          wflowName: "=?",
          editable: "=",
          showFields: "=?",
          treeId: "=?"
        },
        controller: WorkflowTreeCtrl,
        controllerAs: "treeCtrl"
      };
    }
  ]).directive("mooWorkflowComponent", [
    function() {
      return {
        restrict: "E",
        templateUrl: "partials/workflow-component.html",
        scope: {
          component: "="
        },
        link: function($scope, element) {
          return element.find("div").draggable({
            helper: "clone",
            cursorAt: {
              top: -5,
              left: -5
            },
            connectToFancytree: true
          });
        }
      };
    }
  ]).directive("mooWorkflowChooser", [
    "$compile", "Workflows", function($compile, Workflows) {
      return {
        restrict: "E",
        templateUrl: "partials/workflow-chooser.html",
        scope: {
          mainBtnText: "=?",
          workflows: "=?"
        },
        controller: function($scope, $element) {
          var loadedWorkflows;
          if ($scope.workflows == null) {
            $scope.workflows = Workflows.query();
          }
          if ($scope.mainBtnText == null) {
            $scope.mainBtnText = "Select";
          }
          $scope.selectWorkflow = function(wf) {
            return $scope.$emit("moo.workflow.selected", wf);
          };
          loadedWorkflows = {};
          return $scope.loadWorkflowTree = function(wfName) {
            var newTree;
            if (loadedWorkflows[wfName] != null) {
              return true;
            }
            $scope.wfName = wfName;
            newTree = $compile("<moo-workflow-tree wflow-name='wfName' editable='false'></moo-workflow-tree>")($scope);
            $element.find("#hidden-row-" + wfName).append(newTree);
            return true;
          };
        }
      };
    }
  ]).directive("mooGreeter", [
    function() {
      return {
        restrict: "E",
        template: 'Name: {{greeter.customer.name}} | Address: {{greeter.customer.address}} | Message: {{greeter.greet()}}  ',
        scope: {
          name: "=?"
        },
        controller: "GreeterCtrl2",
        controllerAs: "greeter"
      };
    }
  ]).directive("mooModal", [
    function() {
      return {
        restrict: "E",
        templateUrl: "partials/modal.html",
        transclude: true,
        scope: {
          title: '@',
          modalId: '@'
        },
        controller: function($scope) {
          $scope.clickedAccept = function() {
            return $scope.$emit("modal.clicked.accept");
          };
          return $scope.clickedClose = function() {
            return $scope.$emit("modal.clicked.close");
          };
        }
      };
    }
  ]);

  angular.module("moo.filters", []).filter("escapeDot", [
    function() {
      return function(text) {
        return text.replace(".", "_");
      };
    }
  ]).filter("wflowIdToName", [
    function() {
      return function(text) {
        return text.m$leftOf(".");
      };
    }
  ]).filter("filterKey", [
    "$filter", function($filter) {
      return function(items, query) {
        var filtered, k, list, result, _i, _len;
        list = (function() {
          var _results;
          _results = [];
          for (k in items) {
            if (!__hasProp.call(items, k)) continue;
            _results.push(k);
          }
          return _results;
        })();
        filtered = $filter("filter")(list, query);
        result = {};
        for (_i = 0, _len = filtered.length; _i < _len; _i++) {
          k = filtered[_i];
          result[k] = items[k];
        }
        return result;
      };
    }
  ]);

  2;

  WorkflowTreeCtrl = (function(_super) {
    __extends(WorkflowTreeCtrl, _super);

    WorkflowTreeCtrl.register(angular.module("moo.directives"));

    WorkflowTreeCtrl.inject("$scope", "Workflows", "$element");

    function WorkflowTreeCtrl($scope, Workflows, $element) {
      var wfName, _ref;
      this.$scope = $scope;
      this.Workflows = Workflows;
      this._configureTrash = __bind(this._configureTrash, this);
      this._afterLoad = __bind(this._afterLoad, this);
      this._onNoExistingWorkflow = __bind(this._onNoExistingWorkflow, this);
      this.save = __bind(this.save, this);
      this.setWorkflow = __bind(this.setWorkflow, this);
      this.givenId = $scope.treeId;
      this.editable = $scope.editable;
      this.showFields = (_ref = $scope.showFields) != null ? _ref : true;
      this.workflowComponents = this.editable ? ACT_FACTORY.draggableActivities() : [];
      wfName = $scope.wflowName;
      this.treeId = wfName != null ? wfName + "-tree" : "tree";
      this.treeSelector = "#" + this.treeId;
      if (this.editable) {
        this._configureTrash($element);
      }
      window.ctrl = this;
      $scope.$on("moo.tree.change", (function(_this) {
        return function(evt, wfName) {
          return _this.setWorkflow(wfName);
        };
      })(this));
      $scope.$on("moo.tree.copy", (function(_this) {
        return function(evt, data) {
          console.log(data);
          _this.setWorkflow(data.wfName);
          return _this.workflow.name(data.newName);
        };
      })(this));
      this.setWorkflow(wfName);
    }

    WorkflowTreeCtrl.prototype.setWorkflow = function(wfName) {
      var onSuccess;
      if (wfName == null) {
        wfName = null;
      }
      if (wfName) {
        onSuccess = (function(_this) {
          return function(wflowData) {
            return _this._afterLoad(ACT_FACTORY.createWorkflow(wflowData, _this.treeSelector, _this.editable));
          };
        })(this);
        return this.Workflows.get(wfName, onSuccess, this._onNoExistingWorkflow);
      } else {
        return this._onNoExistingWorkflow();
      }
    };

    WorkflowTreeCtrl.prototype.save = function() {
      var onFail, onSuccess, xml;
      if (!this.editable) {
        console.log("Can't save when in read only mode");
        return;
      }
      xml = this.workflow.toXml();
      console.log(xml);
      onSuccess = function() {
        return alert("Workflow save");
      };
      onFail = (function(_this) {
        return function(data) {
          console.log("Error: %o", data);
          if (data.status !== 409) {
            alert("Error see console");
          }
          return _this.$scope.$emit("moo.workflow.save.error." + data.status, {
            name: _this.workflow.name(),
            instances: data.data,
            retry: _this.save
          });
        };
      })(this);
      return this.Workflows.update(this.workflow.name(), xml, onSuccess, onFail);
    };

    WorkflowTreeCtrl.prototype._onNoExistingWorkflow = function() {
      var errorMsg;
      if (this.editable) {
        return this._afterLoad(ACT_FACTORY.createEmptyWorkflow(this.treeSelector, this.editable, "NewWorkflow"));
      } else {
        errorMsg = "If workflow is not editable, then workflow must already exist";
        alert(errorMsg);
        return console.log(errorMsg);
      }
    };

    WorkflowTreeCtrl.prototype._afterLoad = function(workflow) {
      this.$scope.$emit("workflow.tree.loaded." + this.givenId);
      this.workflow = workflow;
      return this.workflow.selectedActivityChanged((function(_this) {
        return function() {
          return _this.$scope.$apply();
        };
      })(this));
    };

    WorkflowTreeCtrl.prototype._configureTrash = function($element) {
      return this.$scope.$watchCollection((function() {
        return $element.find(".trash");
      }), function() {
        console.log("watch");
        return $element.find(".trash").droppable({
          drop: function(event, ui) {
            var sourceNode;
            sourceNode = $(ui.helper).data("ftSourceNode");
            return sourceNode.remove();
          }
        });
      });
    };

    return WorkflowTreeCtrl;

  })(BaseCtrl);

}).call(this);

//# sourceMappingURL=moo.map
