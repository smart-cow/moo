// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty;

  angular.module("moo.services", ["ngResource"]).constant("ResourceHelpers", {
    fixVars: function(resource) {
      var _ref, _ref1, _ref2, _ref3;
      if (!angular.isArray(resource.variables)) {
        resource.variables = (_ref = (_ref1 = (_ref2 = resource.variables) != null ? _ref2.variable : void 0) != null ? _ref1 : (_ref3 = resource.variables) != null ? _ref3.variables : void 0) != null ? _ref : [];
      }
      return resource;
    },
    fixOutcomes: function(resource) {
      var _ref, _ref1;
      if (!angular.isArray(resource.outcomes)) {
        resource.outcomes = (_ref = (_ref1 = resource.outcome) != null ? _ref1 : resource.outcomes) != null ? _ref : [];
        delete resource.outcome;
      }
      return resource;
    },
    encodeVars: function(variables) {
      var v;
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = variables.length; _i < _len; _i++) {
          v = variables[_i];
          _results.push("" + v.name + ":" + v.value);
        }
        return _results;
      })();
    },
    promiseParam: function(promise, isArray, serviceCall) {
      var promiseThen, resolvedObj, _ref;
      resolvedObj = isArray ? [] : {};
      promiseThen = (_ref = promise.then) != null ? _ref : promise.$promise.then;
      promiseThen(function(promisedData) {
        return serviceCall(promisedData).$promise.then(function(serviceData) {
          var k, v, _results;
          _results = [];
          for (k in serviceData) {
            if (!__hasProp.call(serviceData, k)) continue;
            v = serviceData[k];
            _results.push(resolvedObj[k] = v);
          }
          return _results;
        });
      });
      return resolvedObj;
    }
  }).factory("CurrentUser", [
    "$resource", "ServiceUrls", function($resource, ServiceUrls) {
      var user, whoamiResource;
      whoamiResource = $resource("" + ServiceUrls.cowServer + "/whoami", {}, {
        get: {
          transformResponse: function(data) {
            var m, userData;
            userData = angular.fromJson(data);
            return {
              name: userData.id,
              groups: (function() {
                var _i, _len, _ref, _results;
                _ref = userData.membership;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  m = _ref[_i];
                  _results.push(m.group);
                }
                return _results;
              })()
            };
          }
        }
      });
      user = whoamiResource.get();
      return user;
    }
  ]).factory("RunningWorkflows", [
    "$resource", "ServiceUrls", function($resource, ServiceUrls) {
      var statuses, workflowsResource;
      workflowsResource = $resource(ServiceUrls.url("processInstances/:id"), {}, {
        query: {
          isArray: true,
          transformResponse: function(data) {
            return JSON.parse(data).processInstance;
          }
        },
        status: {
          url: ServiceUrls.url("processInstances/:id/status")
        },
        deleteAllOfType: {
          url: ServiceUrls.url("processes/:id/processInstances"),
          method: "DELETE"
        }
      });
      statuses = [];
      return {
        workflows: workflowsResource.query,
        getStatuses: function() {
          workflowsResource.query().$promise.then(function(workflows) {
            var idNum, wf, _i, _len, _results;
            _results = [];
            for (_i = 0, _len = workflows.length; _i < _len; _i++) {
              wf = workflows[_i];
              idNum = wf.id.m$rightOf(".");
              _results.push(workflowsResource.status({
                id: idNum
              }, function(status) {
                return statuses.push({
                  id: status.id,
                  status: status.statusSummary
                });
              }));
            }
            return _results;
          });
          return statuses;
        },
        deleteInstance: function(id) {
          id = id.m$rightOf(".");
          return workflowsResource["delete"]({
            id: id
          });
        },
        deleteAllInstancesOfType: function(name) {
          return workflowsResource.deleteAllOfType({
            id: name
          });
        }
      };
    }
  ]).factory("Processes", [
    "$resource", "ServiceUrls", function($resource, ServiceUrls) {
      var processResource;
      processResource = $resource(ServiceUrls.url("processes/:id"));
      return {
        get: function(id, onSuccess, onFailure) {
          return processResource.get({
            id: id
          }, onSuccess, onFailure);
        }
      };
    }
  ]).factory("ScowPush", [
    "ServiceUrls", function(ServiceUrls) {
      var addSubscription, init;
      addSubscription = function() {};
      init = function() {
        var amqpInfo, amqpSubscribe, isConnected, stomp, stompConnect, subscriptions;
        amqpInfo = ServiceUrls.amqp;
        stomp = Stomp.over(new SockJS(amqpInfo.url));
        stomp.debug = function() {};
        subscriptions = [];
        isConnected = false;
        addSubscription = function(subscription) {
          subscriptions.push(subscription);
          if (isConnected) {
            return amqpSubscribe(subscription);
          }
        };
        amqpSubscribe = function(subscription) {
          var destination;
          destination = amqpInfo.exchange + subscription.routingKey;
          return stomp.subscribe(destination, function(message) {
            var parsedBody, routingKey;
            routingKey = message.headers.destination.m$rightOf("/");
            parsedBody = angular.fromJson(message.body);
            return subscription.onReceive(parsedBody, routingKey);
          });
        };
        stompConnect = function() {
          var onConnect, onError;
          onConnect = function() {
            var s, _i, _len, _results;
            console.log("Stomp connected");
            isConnected = true;
            _results = [];
            for (_i = 0, _len = subscriptions.length; _i < _len; _i++) {
              s = subscriptions[_i];
              _results.push(amqpSubscribe(s));
            }
            return _results;
          };
          onError = function() {
            isConnected = false;
            return console.log("Error while trying to connect to AMQP");
          };
          return stomp.connect(amqpInfo.username, amqpInfo.password, onConnect, onError);
        };
        return stompConnect();
      };
      init();
      return {
        subscribe: function(routingKey, onReceive) {
          console.log(routingKey);
          return addSubscription({
            routingKey: routingKey,
            onReceive: onReceive
          });
        }
      };
    }
  ]);

  angular.module("moo.directives", []).directive("mooNavMenu", [
    "$route", "Areas", function($route, Areas) {
      return {
        restrict: "E",
        templateUrl: "partials/nav-menu.html",
        link: function($scope) {
          var area;
          $scope.tabs = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = Areas.length; _i < _len; _i++) {
              area = Areas[_i];
              _results.push({
                title: area.name,
                url: "#" + area.defaultRoute.url,
                selected: area.name === $route.current.provide.area
              });
            }
            return _results;
          })();
          return $scope.$on("$routeChangeSuccess", function(evt, newRoute) {
            var tab, _i, _len, _ref, _results;
            _ref = $scope.tabs;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              tab = _ref[_i];
              _results.push(tab.selected = tab.title === newRoute.provide.area);
            }
            return _results;
          });
        }
      };
    }
  ]).directive("mooEditableVariables", [
    function() {
      return {
        restrict: "E",
        templateUrl: "partials/editable-variables.html",
        scope: {
          variables: "="
        }
      };
    }
  ]).directive("mooReadOnlyVariables", [
    function() {
      return {
        restrict: "E",
        templateUrl: "partials/read-only-variables.html",
        scope: {
          variables: "="
        }
      };
    }
  ]).directive("mooWorkflowTree", [
    "Processes", function(Processes) {
      return {
        restrict: "E",
        templateUrl: "partials/workflow-tree.html",
        scope: {
          wflowName: "=?",
          editable: "=",
          treeId: "=?"
        },
        link: function($scope) {
          var treeSelector;
          if ($scope.treeId == null) {
            $scope.treeId = $scope.wflowName != null ? $scope.wflowName + "-tree" : "tree";
          }
          treeSelector = "#" + $scope.treeId;
          $(".trash").droppable({
            drop: function(event, ui) {
              var sourceNode;
              sourceNode = $(ui.helper).data("ftSourceNode");
              return sourceNode.remove();
            }
          });
          $scope.workflowComponents = ACT_FACTORY.draggableActivities();
          $scope.$watch($scope.workflowComponents, function() {
            return $(".draggable").draggable({
              helper: "clone",
              cursorAt: {
                top: -5,
                left: -5
              },
              connectToFancytree: true
            });
          });
          $scope.$watch($scope.treeId, function() {
            var afterLoad, onNoExistingWorkflow, onSuccess;
            afterLoad = function(workflow) {
              $scope.workflow = workflow;
              return workflow.selectedActivityChanged(function() {
                return $scope.$apply();
              });
            };
            onNoExistingWorkflow = function() {
              return afterLoad(ACT_FACTORY.createEmptyWorkflow(treeSelector, $scope.editable, $scope.wflowName));
            };
            if ($scope.wflowName != null) {
              onSuccess = function(wflowData) {
                return afterLoad(ACT_FACTORY.createWorkflow(wflowData, treeSelector, $scope.editable));
              };
              return Processes.get($scope.wflowName, onSuccess, onNoExistingWorkflow);
            } else {
              return onNoExistingWorkflow();
            }
          });
          return $scope.save = function() {
            var xml;
            xml = $scope.workflow.toXml();
            return console.log(xml);
          };
        }
      };
    }
  ]);

}).call(this);

//# sourceMappingURL=moo.map
