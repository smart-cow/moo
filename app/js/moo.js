// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty;

  angular.module("moo.directives", []).directive("mooNavMenu", [
    "$route", "Areas", function($route, Areas) {
      return {
        restrict: "E",
        templateUrl: "partials/nav-menu.html",
        link: function($scope) {
          var area;
          $scope.tabs = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = Areas.length; _i < _len; _i++) {
              area = Areas[_i];
              _results.push({
                title: area.name,
                url: "#" + area.defaultRoute.url,
                selected: area.name === $route.current.provide.area
              });
            }
            return _results;
          })();
          return $scope.$on("$routeChangeSuccess", function(evt, newRoute) {
            var tab, _i, _len, _ref, _results;
            _ref = $scope.tabs;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              tab = _ref[_i];
              _results.push(tab.selected = tab.title === newRoute.provide.area);
            }
            return _results;
          });
        }
      };
    }
  ]).directive("mooEditableVariables", [
    function() {
      return {
        restrict: "E",
        templateUrl: "partials/editable-variables.html",
        scope: {
          variables: "="
        }
      };
    }
  ]).directive("mooReadOnlyVariables", [
    function() {
      return {
        restrict: "E",
        templateUrl: "partials/read-only-variables.html",
        scope: {
          variables: "="
        }
      };
    }
  ]);

  angular.module("moo.services", ["ngResource"]).constant("ResourceHelpers", {
    fixVars: function(resource) {
      var _ref, _ref1, _ref2, _ref3;
      return resource.variables = (_ref = (_ref1 = (_ref2 = resource.variables) != null ? _ref2.variable : void 0) != null ? _ref1 : (_ref3 = resource.variables) != null ? _ref3.variables : void 0) != null ? _ref : [];
    },
    encodeVars: function(variables) {
      var v, varPairs;
      if (variables.length === 0) {
        return null;
      }
      varPairs = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = variables.length; _i < _len; _i++) {
          v = variables[_i];
          _results.push("var=" + v.name + ":" + v.value);
        }
        return _results;
      })();
      return varPairs.join("&");
    },
    promiseParam: function(promise, isArray, serviceCall) {
      var promiseThen, resolvedObj, _ref;
      resolvedObj = isArray ? [] : {};
      promiseThen = (_ref = promise.then) != null ? _ref : promise.$promise.then;
      promiseThen(function(promisedData) {
        return serviceCall(promisedData).$promise.then(function(serviceData) {
          var k, v, _results;
          _results = [];
          for (k in serviceData) {
            if (!__hasProp.call(serviceData, k)) continue;
            v = serviceData[k];
            _results.push(resolvedObj[k] = v);
          }
          return _results;
        });
      });
      return resolvedObj;
    }
  }).factory("CurrentUser", [
    "$resource", "ServiceUrls", function($resource, ServiceUrls) {
      var user, whoamiResource;
      whoamiResource = $resource("" + ServiceUrls.cowServer + "/whoami", {}, {
        get: {
          transformResponse: function(data) {
            var m, userData;
            userData = angular.fromJson(data);
            return {
              name: userData.id,
              groups: (function() {
                var _i, _len, _ref, _results;
                _ref = userData.membership;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  m = _ref[_i];
                  _results.push(m.group);
                }
                return _results;
              })()
            };
          }
        }
      });
      user = whoamiResource.get();
      return user;
    }
  ]).factory("RunningWorkflows", [
    "$resource", "ServiceUrls", function($resource, ServiceUrls) {
      var statuses, workflowsResource;
      workflowsResource = $resource("" + ServiceUrls.cowServer + "/processInstances/:id", {}, {
        query: {
          isArray: true,
          transformResponse: function(data) {
            return JSON.parse(data).processInstance;
          }
        },
        status: {
          url: "" + ServiceUrls.cowServer + "/processInstances/:id/status"
        }
      });
      statuses = [];
      return {
        workflows: workflowsResource.query(),
        getStatuses: function() {
          workflowsResource.query().$promise.then(function(workflows) {
            var idNum, wf, _i, _len, _results;
            _results = [];
            for (_i = 0, _len = workflows.length; _i < _len; _i++) {
              wf = workflows[_i];
              idNum = wf.id.m$rightOf(".");
              _results.push(workflowsResource.status({
                id: idNum
              }, function(status) {
                return statuses.push({
                  id: status.id,
                  status: status.statusSummary
                });
              }));
            }
            return _results;
          });
          return statuses;
        }
      };
    }
  ]).factory("ScowPush", [
    "ServiceUrls", function(ServiceUrls) {
      var addSubscription, amqpInfo, amqpSubscribe, isConnected, onConnect, onError, stomp, stompConnect, subscriptions;
      amqpInfo = ServiceUrls.amqp;
      stomp = Stomp.over(new SockJS(amqpInfo.url));
      subscriptions = [];
      isConnected = false;
      addSubscription = function(subscription) {
        subscriptions.push(subscription);
        if (isConnected) {
          return amqpSubscribe(subscription);
        }
      };
      amqpSubscribe = function(subscription) {
        var destination;
        destination = amqpInfo.exchange + subscription.routingKey;
        return stomp.subscribe(destination, function(message) {
          var parsedBody, routingKey;
          routingKey = message.headers.destination.m$rightOf("/");
          parsedBody = angular.fromJson(message.body);
          return subscription.onReceive(parsedBody, routingKey);
        });
      };
      onConnect = function() {
        var s, _i, _len, _results;
        console.log("Stomp connected");
        isConnected = true;
        _results = [];
        for (_i = 0, _len = subscriptions.length; _i < _len; _i++) {
          s = subscriptions[_i];
          _results.push(amqpSubscribe(s));
        }
        return _results;
      };
      onError = function() {
        isConnected = false;
        return console.log("Error while trying to connect to AMQP");
      };
      stompConnect = function() {
        return stomp.connect(amqpInfo.username, amqpInfo.password, onConnect, onError);
      };
      stompConnect();
      return {
        subscribe: function(routingKey, onReceive) {
          console.log(routingKey);
          return addSubscription({
            routingKey: routingKey,
            onReceive: onReceive
          });
        }
      };
    }
  ]);

}).call(this);

//# sourceMappingURL=moo.map
