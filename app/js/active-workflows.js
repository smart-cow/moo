// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty;

  angular.module("moo.active-workflows.controllers", ["moo.active-workflows.services"]).controller("ActiveWorkflowsCtrl", [
    "$scope", "WorkflowSummary", function($scope, WorkflowSummary) {
      var selectedWorkflows;
      $scope.workflowSummaries = WorkflowSummary;
      selectedWorkflows = {};
      $scope.selectWorkflow = function(wflowName) {
        if (selectedWorkflows[wflowName] == null) {
          selectedWorkflows[wflowName] = false;
        }
        return selectedWorkflows[wflowName] = !selectedWorkflows[wflowName];
      };
      return $scope.isSelected = function(wflowName) {
        var _ref;
        return (_ref = selectedWorkflows[wflowName]) != null ? _ref : false;
      };
    }
  ]);

  angular.module("moo.active-workflows.services", []).factory("WorkflowSummary", [
    "$rootScope", "$resource", "ServiceUrls", "ScowPush", function($rootScope, $resource, ServiceUrls, ScowPush) {
      var statusPriority, updateStatus, updateWorkflow, wflowResource, wflowsSummary;
      wflowsSummary = {
        headings: {},
        workflows: {}
      };
      updateWorkflow = function(wflowName) {
        var id;
        id = wflowName.m$rightOf(".");
        return wflowResource.status({
          id: id
        });
      };
      statusPriority = ["precluded", "completed", "contingent", "planned", "notStarted", "open"];
      updateStatus = function(newStatuses) {
        var addedNames, convertToMap, existingStatuses, name, newStatusesMap, removedNames, status, updateHeadings, _base, _name;
        convertToMap = function(statuses) {
          var higherPriority, st, statusesMap, _i, _len, _ref;
          higherPriority = function(status1, status2) {
            var index1, index2;
            index1 = statusPriority.indexOf(status1);
            index2 = statusPriority.indexOf(status2);
            if (index1 > index2) {
              return status1;
            } else {
              return status2;
            }
          };
          statusesMap = {};
          _ref = statuses.statuses;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            st = _ref[_i];
            statusesMap[st.name] = higherPriority(st.status, statusesMap[st.name]);
          }
          return statusesMap;
        };
        updateHeadings = function(addedNames, removedNames) {
          var addedName, heading, headingsToRemove, n, nameInOtherWflow, _i, _j, _len, _len1, _results;
          nameInOtherWflow = function(name) {
            var status, statuses, user, wflowName, _ref;
            _ref = wflowsSummary.workflows;
            for (wflowName in _ref) {
              if (!__hasProp.call(_ref, wflowName)) continue;
              statuses = _ref[wflowName];
              for (user in statuses) {
                if (!__hasProp.call(statuses, user)) continue;
                status = statuses[user];
                if (user === name) {
                  return true;
                }
              }
            }
            return false;
          };
          for (_i = 0, _len = addedNames.length; _i < _len; _i++) {
            addedName = addedNames[_i];
            wflowsSummary.headings[addedName] = true;
          }
          headingsToRemove = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = removedNames.length; _j < _len1; _j++) {
              n = removedNames[_j];
              if (!nameInOtherWflow(n)) {
                _results.push(nameInOtherWflow(n));
              }
            }
            return _results;
          })();
          _results = [];
          for (_j = 0, _len1 = headingsToRemove.length; _j < _len1; _j++) {
            heading = headingsToRemove[_j];
            _results.push(delete wflowsSummary.headings[heading]);
          }
          return _results;
        };
        if ((_base = wflowsSummary.workflows)[_name = newStatuses.name] == null) {
          _base[_name] = {};
        }
        existingStatuses = wflowsSummary.workflows[newStatuses.name];
        newStatusesMap = convertToMap(newStatuses);
        addedNames = [];
        for (name in newStatusesMap) {
          if (!__hasProp.call(newStatusesMap, name)) continue;
          status = newStatusesMap[name];
          if (existingStatuses[name] == null) {
            addedNames.push(name);
          }
          existingStatuses[name] = status;
        }
        removedNames = [];
        for (name in existingStatuses) {
          if (!__hasProp.call(existingStatuses, name)) continue;
          status = existingStatuses[name];
          if (newStatusesMap[name] == null) {
            removedNames.push(name);
            delete existingStatuses[name];
          }
        }
        return updateHeadings(addedNames, removedNames);
      };
      wflowResource = $resource(ServiceUrls.url("processInstances/:id"), {}, {
        query: {
          isArray: true,
          transformResponse: function(data) {
            var name, names, wflow, wflowInstances, _i, _len;
            wflowInstances = angular.fromJson(data).processInstance;
            names = [];
            for (_i = 0, _len = wflowInstances.length; _i < _len; _i++) {
              wflow = wflowInstances[_i];
              name = wflow.id;
              updateWorkflow(name);
              names.push(name);
            }
            return names;
          }
        },
        status: {
          url: ServiceUrls.url("processInstances/:id/status"),
          transformResponse: function(data) {
            var name, ss, status, statusSummary, wflowStatus;
            wflowStatus = angular.fromJson(data);
            name = wflowStatus.id;
            statusSummary = wflowStatus.statusSummary;
            status = {
              name: name,
              statuses: (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = statusSummary.length; _i < _len; _i++) {
                  ss = statusSummary[_i];
                  if (ss.name !== "") {
                    _results.push({
                      name: ss.name,
                      status: ss.status
                    });
                  }
                }
                return _results;
              })()
            };
            updateStatus(status);
            return status;
          }
        }
      });
      wflowResource.query();
      ScowPush.subscribe("#.tasks.#", function(task) {
        return $rootScope.$apply(function() {
          return updateWorkflow(task.processInstanceId);
        });
      });
      return wflowsSummary;
    }
  ]);

}).call(this);

//# sourceMappingURL=active-workflows.map
